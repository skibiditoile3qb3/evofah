<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Texas Hold'em Poker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Arial', sans-serif;
        }

        body {
            background: linear-gradient(145deg, #0a0e27, #1a1a2e);
            color: white;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .game-container {
            max-width: 1200px;
            width: 100%;
            background: linear-gradient(145deg, #035c3d, #024d33);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 10px 50px rgba(0,0,0,0.5);
        }

        .info-bar {
            display: flex;
            justify-content: space-between;
            margin-bottom: 30px;
            padding: 15px 20px;
            background: rgba(0,0,0,0.6);
            border-radius: 10px;
        }

        .balance {
            font-size: 20px;
            font-weight: bold;
            color: #00ff9d;
        }

        .pot-display {
            font-size: 24px;
            font-weight: bold;
            color: #ffd700;
        }

        .setup-screen {
            text-align: center;
            padding: 40px;
        }

        .setup-screen h1 {
            font-size: 48px;
            margin-bottom: 40px;
            color: #00ff9d;
            text-shadow: 0 0 20px rgba(0, 255, 157, 0.5);
        }

        .setup-options {
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-width: 400px;
            margin: 0 auto;
        }

        .setup-option {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .setup-option label {
            font-size: 18px;
        }

        .setup-option select,
        .setup-option input {
            padding: 10px 20px;
            background: rgba(0,0,0,0.5);
            border: 2px solid #00ff9d;
            border-radius: 5px;
            color: white;
            font-size: 16px;
            min-width: 150px;
        }

        .start-btn {
            margin-top: 30px;
            padding: 15px 60px;
            background: #00ff9d;
            border: none;
            border-radius: 10px;
            color: #000;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        .start-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 20px rgba(0, 255, 157, 0.5);
        }

        .game-area {
            display: none;
        }

        .players-area {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }

        .player {
            background: rgba(0,0,0,0.6);
            padding: 15px;
            border-radius: 10px;
            border: 3px solid transparent;
            transition: all 0.3s;
        }

        .player.active {
            border-color: #00ff9d;
            box-shadow: 0 0 20px rgba(0, 255, 157, 0.5);
        }

        .player.folded {
            opacity: 0.4;
        }

        .player-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .player-name {
            font-size: 18px;
            font-weight: bold;
        }

        .player-chips {
            color: #00ff9d;
            font-weight: bold;
        }

        .player-bet {
            color: #ffd700;
            margin-bottom: 10px;
        }

        .player-cards {
            display: flex;
            gap: 8px;
            justify-content: center;
        }

        .card {
            width: 60px;
            height: 84px;
            background: white;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            position: relative;
        }

        .card.back {
            background: linear-gradient(135deg, #1a237e, #3949ab);
            color: white;
        }

        .card-value {
            font-size: 20px;
            font-weight: bold;
            position: absolute;
            top: 5px;
            left: 5px;
        }

        .card-suit {
            font-size: 36px;
        }

        .card.red {
            color: #e53935;
        }

        .card.black {
            color: #000;
        }

        .community-area {
            text-align: center;
            margin: 40px 0;
        }

        .community-cards {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
        }

        .community-area .card {
            width: 80px;
            height: 112px;
        }

        .community-area .card-value {
            font-size: 24px;
        }

        .community-area .card-suit {
            font-size: 48px;
        }

        .hand-rank {
            font-size: 18px;
            color: #4da6ff;
            font-weight: bold;
            margin-top: 10px;
        }

        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
        }

        .btn {
            padding: 15px 30px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
        }

        .btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .btn:not(:disabled):hover {
            transform: translateY(-2px);
        }

        .btn-fold {
            background: #e53935;
            color: white;
        }

        .btn-check {
            background: #4da6ff;
            color: white;
        }

        .btn-call {
            background: #00ff9d;
            color: #000;
        }

        .btn-raise {
            background: #b026ff;
            color: white;
        }

        .raise-input {
            padding: 15px 20px;
            border: 2px solid #b026ff;
            border-radius: 8px;
            background: rgba(0,0,0,0.5);
            color: white;
            font-size: 16px;
            width: 150px;
            text-align: center;
        }

        .message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            padding: 30px 60px;
            border-radius: 15px;
            font-size: 24px;
            font-weight: bold;
            color: #00ff9d;
            z-index: 1000;
            box-shadow: 0 0 30px rgba(0, 255, 157, 0.5);
            display: none;
        }

        .message.show {
            display: block;
        }

        .new-hand-btn {
            display: block;
            margin: 30px auto 0;
            padding: 12px 40px;
            background: #ffd700;
            color: #000;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="setup-screen" id="setupScreen">
            <h1>♠ TEXAS HOLD'EM ♥</h1>
            <div class="setup-options">
                <div class="setup-option">
                    <label>Players:</label>
                    <select id="playerCount">
                        <option value="3">3 Players</option>
                        <option value="4" selected>4 Players</option>
                        <option value="5">5 Players</option>
                        <option value="6">6 Players</option>
                    </select>
                </div>
                <div class="setup-option">
                    <label>Small Blind:</label>
                    <input type="number" id="smallBlind" value="10" min="5" step="5">
                </div>
            </div>
            <button class="start-btn" onclick="startGame()">START GAME</button>
        </div>

        <div class="game-area" id="gameArea">
            <div class="info-bar">
                <div class="balance">Chips: $<span id="balance">0</span></div>
                <div class="pot-display">Pot: $<span id="pot">0</span></div>
            </div>

            <div class="players-area" id="playersArea"></div>

            <div class="community-area">
                <div class="community-cards" id="communityCards"></div>
                <div class="hand-rank" id="handRank"></div>
            </div>

            <div class="controls" id="controls" style="display: none;">
                <button class="btn btn-fold" onclick="playerAction('fold')">Fold</button>
                <button class="btn btn-check" id="checkBtn" onclick="playerAction('check')">Check</button>
                <button class="btn btn-call" id="callBtn" onclick="playerAction('call')">Call $<span id="callAmount">0</span></button>
                <input type="number" class="raise-input" id="raiseAmount" min="0" step="10" value="20" placeholder="Raise">
                <button class="btn btn-raise" onclick="playerAction('raise')">Raise</button>
            </div>

            <button class="new-hand-btn" id="newHandBtn" onclick="newHand()" style="display: none;">New Hand</button>
        </div>

        <div class="message" id="message"></div>
    </div>

    <script>
        const suits = ['♥', '♦', '♠', '♣'];
        const values = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
        const valueMap = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14};

        let state = {
            deck: [],
            players: [],
            communityCards: [],
            pot: 0,
            currentBet: 0,
            currentPlayerIndex: 0,
            dealerIndex: 0,
            smallBlind: 10,
            bigBlind: 20,
            phase: 'preflop',
            gameActive: false,
            humanBalance: 0
        };

        // Coin integration
        window.parent.postMessage({ type: 'getCoins' }, '*');

        window.addEventListener('message', (event) => {
            if (event.data.type === 'coinsData') {
                state.humanBalance = event.data.coins;
                const humanPlayer = state.players.find(p => p.isHuman);
                if (humanPlayer) {
                    humanPlayer.chips = state.humanBalance;
                    updateDisplay();
                }
            }
        });

        function updateParentCoins() {
            window.parent.postMessage({
                type: 'updateCoins',
                coins: state.humanBalance
            }, '*');
        }

        function createDeck() {
            const deck = [];
            for (const suit of suits) {
                for (const value of values) {
                    deck.push({ suit, value });
                }
            }
            return shuffleDeck(deck);
        }

        function shuffleDeck(deck) {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            return deck;
        }

        function startGame() {
            const playerCount = parseInt(document.getElementById('playerCount').value);
            const smallBlind = parseInt(document.getElementById('smallBlind').value);

            if (state.humanBalance < smallBlind * 2) {
                alert('You need at least ' + (smallBlind * 2) + ' coins to play!');
                return;
            }

            state.smallBlind = smallBlind;
            state.bigBlind = smallBlind * 2;

            state.players = [];
            state.players.push({ 
                name: 'You', 
                isHuman: true, 
                chips: state.humanBalance, 
                cards: [], 
                bet: 0, 
                folded: false, 
                allIn: false,
                hasActed: false
            });

            const aiNames = ['Alice', 'Bob', 'Charlie', 'Diana', 'Eve'];
            for (let i = 0; i < playerCount - 1; i++) {
                state.players.push({
                    name: aiNames[i],
                    isHuman: false,
                    chips: state.humanBalance,
                    cards: [],
                    bet: 0,
                    folded: false,
                    allIn: false,
                    hasActed: false
                });
            }

            document.getElementById('setupScreen').style.display = 'none';
            document.getElementById('gameArea').style.display = 'block';

            renderPlayers();
            newHand();
        }

        function renderPlayers() {
            const container = document.getElementById('playersArea');
            container.innerHTML = '';

            state.players.forEach((player, index) => {
                const div = document.createElement('div');
                div.className = 'player';
                div.id = `player-${index}`;
                div.innerHTML = `
                    <div class="player-header">
                        <span class="player-name">${player.name}</span>
                        <span class="player-chips">$${player.chips}</span>
                    </div>
                    <div class="player-bet" id="bet-${index}"></div>
                    <div class="player-cards" id="cards-${index}"></div>
                `;
                container.appendChild(div);
            });
        }

        function newHand() {
            state.deck = createDeck();
            state.communityCards = [];
            state.pot = 0;
            state.currentBet = 0;
            state.phase = 'preflop';
            state.gameActive = true;

            state.players.forEach(player => {
                player.cards = [];
                player.bet = 0;
                player.folded = false;
                player.allIn = false;
                player.hasActed = false;
            });

            state.players = state.players.filter(p => p.chips > 0);

            if (state.players.length < 2) {
                showMessage('Game Over! Not enough players.', 3000);
                return;
            }

            state.dealerIndex = (state.dealerIndex + 1) % state.players.length;

            document.getElementById('communityCards').innerHTML = '';
            document.getElementById('handRank').textContent = '';
            document.getElementById('newHandBtn').style.display = 'none';
            document.getElementById('controls').style.display = 'none';

            postBlinds();
            dealCards();
            updateDisplay();

            state.currentPlayerIndex = (state.dealerIndex + 3) % state.players.length;
            
            setTimeout(() => {
                nextPlayer();
            }, 1000);
        }

        function postBlinds() {
            const sbIndex = (state.dealerIndex + 1) % state.players.length;
            const bbIndex = (state.dealerIndex + 2) % state.players.length;

            const sbAmount = Math.min(state.smallBlind, state.players[sbIndex].chips);
            const bbAmount = Math.min(state.bigBlind, state.players[bbIndex].chips);

            state.players[sbIndex].chips -= sbAmount;
            state.players[sbIndex].bet = sbAmount;
            state.pot += sbAmount;

            state.players[bbIndex].chips -= bbAmount;
            state.players[bbIndex].bet = bbAmount;
            state.pot += bbAmount;

            state.currentBet = bbAmount;

            // Update human balance if they posted blinds
            const humanPlayer = state.players.find(p => p.isHuman);
            if (humanPlayer) {
                state.humanBalance = humanPlayer.chips;
                updateParentCoins();
            }
        }

        function dealCards() {
            for (let i = 0; i < 2; i++) {
                state.players.forEach(player => {
                    player.cards.push(state.deck.pop());
                });
            }
        }

        function renderCard(card, faceDown = false) {
            if (faceDown) {
                return '<div class="card back">?</div>';
            }
            const color = (card.suit === '♥' || card.suit === '♦') ? 'red' : 'black';
            return `
                <div class="card ${color}">
                    <div class="card-value">${card.value}</div>
                    <div class="card-suit">${card.suit}</div>
                </div>
            `;
        }

        function updateDisplay() {
            state.players.forEach((player, index) => {
                const playerDiv = document.getElementById(`player-${index}`);
                if (!playerDiv) return;

                playerDiv.className = 'player';
                if (index === state.currentPlayerIndex && state.gameActive) {
                    playerDiv.classList.add('active');
                }
                if (player.folded) {
                    playerDiv.classList.add('folded');
                }

                playerDiv.querySelector('.player-chips').textContent = `$${player.chips}`;
                
                const betDiv = document.getElementById(`bet-${index}`);
                betDiv.textContent = player.bet > 0 ? `Bet: $${player.bet}` : '';

                const cardsDiv = document.getElementById(`cards-${index}`);
                cardsDiv.innerHTML = player.cards.map(card => 
                    renderCard(card, !player.isHuman && state.phase !== 'showdown')
                ).join('');
            });

            const communityDiv = document.getElementById('communityCards');
            communityDiv.innerHTML = state.communityCards.map(card => renderCard(card)).join('');

            document.getElementById('pot').textContent = state.pot;
            const humanPlayer = state.players.find(p => p.isHuman);
            if (humanPlayer) {
                document.getElementById('balance').textContent = humanPlayer.chips;
            }

            if (humanPlayer && !humanPlayer.folded && state.communityCards.length >= 3) {
                const hand = evaluateHand([...humanPlayer.cards, ...state.communityCards]);
                document.getElementById('handRank').textContent = hand.name;
            }
        }

        function playerAction(action) {
            const player = state.players[0];
            if (!player || player.folded || !player.isHuman || state.currentPlayerIndex !== 0) return;

            if (action === 'fold') {
                player.folded = true;
                player.hasActed = true;
                showMessage('You fold', 1000);
            } else if (action === 'check') {
                player.hasActed = true;
                showMessage('You check', 1000);
            } else if (action === 'call') {
                const callAmount = state.currentBet - player.bet;
                const amount = Math.min(callAmount, player.chips);
                player.chips -= amount;
                player.bet += amount;
                state.pot += amount;
                if (player.chips === 0) player.allIn = true;
                player.hasActed = true;
                state.humanBalance = player.chips;
                updateParentCoins();
                showMessage(`You call $${amount}`, 1000);
            } else if (action === 'raise') {
                const raiseAmount = parseInt(document.getElementById('raiseAmount').value);
                const totalNeeded = state.currentBet - player.bet + raiseAmount;
                const amount = Math.min(totalNeeded, player.chips);
                
                player.chips -= amount;
                player.bet += amount;
                state.pot += amount;
                state.currentBet = player.bet;
                if (player.chips === 0) player.allIn = true;
                player.hasActed = true;
                
                state.players.forEach((p, i) => {
                    if (i !== 0 && !p.folded && !p.allIn) {
                        p.hasActed = false;
                    }
                });
                
                state.humanBalance = player.chips;
                updateParentCoins();
                showMessage(`You raise to $${player.bet}`, 1000);
            }

            document.getElementById('controls').style.display = 'none';
            updateDisplay();

            const activePlayers = state.players.filter(p => !p.folded);
            if (activePlayers.length === 1) {
                setTimeout(() => endHand(), 1500);
            } else if (bettingRoundComplete()) {
                setTimeout(() => nextPhase(), 1500);
            } else {
                setTimeout(() => nextPlayer(), 1500);
            }
        }

        function nextPlayer() {
            let attempts = 0;
            while (attempts < state.players.length) {
                state.currentPlayerIndex = (state.currentPlayerIndex + 1) % state.players.length;
                const player = state.players[state.currentPlayerIndex];

                if (!player.folded && !player.allIn) {
                    updateDisplay();

                    if (player.isHuman) {
                        showControls();
                    } else {
                        setTimeout(() => aiAction(), 1500);
                    }
                    return;
                }
                attempts++;
            }

            if (bettingRoundComplete()) {
                nextPhase();
            }
        }

        function showControls() {
            const player = state.players[0];
            const callAmount = state.currentBet - player.bet;

            document.getElementById('controls').style.display = 'flex';
            document.getElementById('checkBtn').disabled = callAmount > 0;
            document.getElementById('callBtn').disabled = callAmount === 0 || player.chips <= callAmount;
            document.getElementById('callAmount').textContent = callAmount;

            const minRaise = Math.max(state.bigBlind, state.currentBet - player.bet + state.bigBlind);
            document.getElementById('raiseAmount').value = minRaise;
            document.getElementById('raiseAmount').min = minRaise;
            document.getElementById('raiseAmount').max = player.chips;
        }

        function bettingRoundComplete() {
            const activePlayers = state.players.filter(p => !p.folded && !p.allIn);
            if (activePlayers.length === 0) return true;
            return activePlayers.every(p => p.hasActed && p.bet === state.currentBet);
        }

function aiAction() {
    const player = state.players[state.currentPlayerIndex];
    const s = player.smartness; // 0–1
    const r = player.risk;      // 0–1 NEW VARIABLE
    const callAmount = state.currentBet - player.bet;

    const handStrength = evaluateHandStrength(player.cards, state.communityCards);
    const random = Math.random();
    const isPreFlop = state.communityCards.length === 0;

    let action = "";

    // Dynamic risk multipliers
    const riskRaiseBoost = 1 + r * 2;       // high risk = bigger raises
    const riskCallBoost = r * 0.5;          // high risk = call more often
    const riskFoldPenalty = r * 0.4;        // high risk = fold less

    // =====================================================
    // 1. DUMB PLAYERS (0.00 – 0.50 smartness)
    // =====================================================
    if (s < 0.50) {

        // 30% + risk chance to raise
        if (random < 0.30 + r * 0.20) {

            const raiseAmount = Math.floor(
                state.bigBlind * (1 + random * 3 * riskRaiseBoost)
            );

            const total = callAmount + raiseAmount;
            const amount = Math.min(total, player.chips);

            player.chips -= amount;
            player.bet += amount;
            state.pot += amount;
            state.currentBet = player.bet;
            if (player.chips === 0) player.allIn = true;

            resetOtherPlayerActions();
            action = "raises";
        }

        // 60% call/check — buffed by risk
        else if (random < 0.90 + riskCallBoost) {
            if (callAmount > 0) {
                callChips(player, callAmount);
                action = "calls";
            } else {
                action = "checks";
            }
        }

        // fold — reduced by risk
        else {
            if (random < 0.10 - riskFoldPenalty) {
                player.folded = true;
                action = "folds";
            } else {
                if (callAmount === 0) action = "checks";
                else {
                    callChips(player, callAmount);
                    action = "calls";
                }
            }
        }
    }

    // =====================================================
    // 2. MID PLAYERS (0.50 – 0.80 smartness)
    // =====================================================
    else if (s < 0.80) {

        // Raise if hand is decent OR risk-taking behavior
        if (handStrength > 0.45 || random < 0.15 + r * 0.25) {

            const raiseAmount = Math.floor(
                state.bigBlind * (1 + random * 2 * riskRaiseBoost)
            );

            const total = callAmount + raiseAmount;
            const amount = Math.min(total, player.chips);

            player.chips -= amount;
            player.bet += amount;
            state.pot += amount;
            state.currentBet = player.bet;
            if (player.chips === 0) player.allIn = true;

            resetOtherPlayerActions();
            action = "raises";
        }

        else if (callAmount === 0) {
            action = "checks";
        }

        // call logic — looser if risky
        else if (
            callAmount < player.chips * (0.30 + riskCallBoost) ||
            handStrength > 0.25 - r * 0.15
        ) {
            callChips(player, callAmount);
            action = "calls";
        }

        else {
            if (random < 0.5 - r * 0.4) {
                player.folded = true;
                action = "folds";
            } else {
                callChips(player, callAmount);
                action = "calls";
            }
        }
    }

    // =====================================================
    // 3. SMART / GENIUS PLAYERS (0.80+ smartness)
    // =====================================================
    else {

        // Pre-flop reads
        if (isPreFlop && callAmount > 0) {

            if (handStrength > 0.25 - r * 0.15 || random < 0.50 + r * 0.30) {
                callChips(player, callAmount);
                action = "calls";
            } else {
                if (random < 0.60 - r * 0.50) {
                    player.folded = true;
                    action = "folds";
                } else {
                    callChips(player, callAmount);
                    action = "calls";
                }
            }
        }

        // Post-flop deeper logic
        else {

            // strong → raise big, risk increases size
            if (handStrength > 0.70) {

                const raiseAmount = Math.floor(
                    state.bigBlind * (2 + random * 3 * riskRaiseBoost)
                );

                const total = callAmount + raiseAmount;
                const amount = Math.min(total, player.chips);

                player.chips -= amount;
                player.bet += amount;
                state.pot += amount;
                state.currentBet = player.bet;
                action = "raises";
            }

            // medium → call/check
            else if (handStrength > 0.40 - r * 0.20) {
                if (callAmount === 0) {
                    action = "checks";
                } else {
                    callChips(player, callAmount);
                    action = "calls";
                }
            }

            // weak → fold unless risky
            else {
                if (callAmount === 0) {
                    action = "checks";
                }
                else if (callAmount < player.chips * (0.10 + r * 0.20)) {
                    callChips(player, callAmount);
                    action = "calls";
                }
                else {
                    if (random < 0.8 - r * 0.7) {
                        player.folded = true;
                        action = "folds";
                    } else {
                        callChips(player, callAmount);
                        action = "calls";
                    }
                }
            }
        }
    }

    // =====================================================
    // Final mechanics
    // =====================================================
    player.hasActed = true;
    showMessage(`${player.name} ${action}`, 1000);
    updateDisplay();

    const activePlayers = state.players.filter(p => !p.folded);
    if (activePlayers.length === 1) {
        setTimeout(() => endHand(), 1500);
    } else if (bettingRoundComplete()) {
        setTimeout(() => nextPhase(), 1500);
    } else {
        setTimeout(() => nextPlayer(), 1500);
    }
}

        function evaluateHandStrength(playerCards, communityCards) {
            const allCards = [...playerCards, ...communityCards];
            if (allCards.length < 2) {
                // Pre-flop hand strength
                const card1Val = valueMap[playerCards[0].value];
                const card2Val = valueMap[playerCards[1].value];
                const isPair = card1Val === card2Val;
                const isHighCards = card1Val >= 11 && card2Val >= 11;
                const isSuited = playerCards[0].suit === playerCards[1].suit;
                
                if (isPair && card1Val >= 10) return 0.85; // High pair
                if (isPair) return 0.65; // Any pair
                if (isHighCards) return 0.70; // Two face cards
                if (card1Val >= 11 || card2Val >= 11) return isSuited ? 0.55 : 0.45; // One high card
                return isSuited ? 0.35 : 0.25; // Low cards
            }

            const hand = evaluateHand(allCards);
            let strength = hand.score / 10;
            
            const highCards = playerCards.filter(c => valueMap[c.value] >= 11).length;
            strength += highCards * 0.05;
            
            return Math.min(strength, 1);
        }

        function nextPhase() {
            state.players.forEach(p => {
                p.bet = 0;
                p.hasActed = false;
            });
            state.currentBet = 0;

            if (state.phase === 'preflop') {
                state.deck.pop();
                state.communityCards.push(state.deck.pop(), state.deck.pop(), state.deck.pop());
                state.phase = 'flop';
            } else if (state.phase === 'flop') {
                state.deck.pop();
                state.communityCards.push(state.deck.pop());
                state.phase = 'turn';
            } else if (state.phase === 'turn') {
                state.deck.pop();
                state.communityCards.push(state.deck.pop());
                state.phase = 'river';
            } else if (state.phase === 'river') {
                endHand();
                return;
            }

            updateDisplay();
            state.currentPlayerIndex = state.dealerIndex;
            setTimeout(() => nextPlayer(), 1000);
        }

        function endHand() {
            state.gameActive = false;
            state.phase = 'showdown';
            updateDisplay();

            const activePlayers = state.players.filter(p => !p.folded);

            if (activePlayers.length === 1) {
                const winner = activePlayers[0];
                winner.chips += state.pot;
                if (winner.isHuman) {
                    state.humanBalance = winner.chips;
                    updateParentCoins();
                }
                showMessage(`${winner.name} wins $${state.pot}!`, 3000);
                updatePlayerDisplay(state.players.indexOf(winner));
            } else {
                const results = activePlayers.map(player => ({
                    player,
                    hand: evaluateHand([...player.cards, ...state.communityCards])
                }));

                results.sort((a, b) => compareHands(b.hand, a.hand));

                const winners = [results[0]];
                for (let i = 1; i < results.length; i++) {
                    if (compareHands(results[i].hand, results[0].hand) === 0) {
                        winners.push(results[i]);
                    } else {
                        break;
                    }
                }

                const winAmount = Math.floor(state.pot / winners.length);
                winners.forEach(w => {
                    w.player.chips += winAmount;
                    if (w.player.isHuman) {
                        state.humanBalance = w.player.chips;
                        updateParentCoins();
                    }
                    updateDisplay();
                });

                const winnerNames = winners.map(w => w.player.name).join(' & ');
                const handName = results[0].hand.name;
                showMessage(`${winnerNames} win${winners.length === 1 ? 's' : ''} ${winAmount} with ${handName}!`, 3500);
            }

            updateDisplay();
            document.getElementById('newHandBtn').style.display = 'block';

            const humanPlayer = state.players.find(p => p.isHuman);
            if (humanPlayer && humanPlayer.chips === 0) {
                setTimeout(() => {
                    showMessage('You are out of chips! Game Over', 3000);
                }, 3500);
            }
        }

        function evaluateHand(cards) {
            if (cards.length < 5) return { name: 'High Card', score: 1, ranks: [] };

            const combinations = [];
            for (let i = 0; i < cards.length - 4; i++) {
                for (let j = i + 1; j < cards.length - 3; j++) {
                    for (let k = j + 1; k < cards.length - 2; k++) {
                        for (let l = k + 1; l < cards.length - 1; l++) {
                            for (let m = l + 1; m < cards.length; m++) {
                                combinations.push([cards[i], cards[j], cards[k], cards[l], cards[m]]);
                            }
                        }
                    }
                }
            }

            let bestHand = { name: 'High Card', score: 1, ranks: [] };
            combinations.forEach(combo => {
                const hand = evaluateFiveCards(combo);
                if (hand.score > bestHand.score || 
                    (hand.score === bestHand.score && compareRanks(hand.ranks, bestHand.ranks) > 0)) {
                    bestHand = hand;
                }
            });

            return bestHand;
        }

        function evaluateFiveCards(cards) {
            const values = cards.map(c => valueMap[c.value]).sort((a, b) => b - a);
            const suits = cards.map(c => c.suit);

            const isFlush = suits.every(s => s === suits[0]);
            const isStraight = values[0] - values[4] === 4 && new Set(values).size === 5;
            const isAceLowStraight = values[0] === 14 && values[1] === 5 && values[2] === 4 && values[3] === 3 && values[4] === 2;

            const counts = {};
            values.forEach(v => counts[v] = (counts[v] || 0) + 1);
            const sortedCounts = Object.entries(counts)
                .map(([val, count]) => ({ val: parseInt(val), count }))
                .sort((a, b) => b.count - a.count || b.val - a.val);

            if (isFlush && (isStraight || isAceLowStraight)) {
                if (values[0] === 14 && values[1] === 13) {
                    return { name: 'Royal Flush', score: 10, ranks: values };
                }
                return { name: 'Straight Flush', score: 9, ranks: values };
            }

            if (sortedCounts[0].count === 4) {
                const kickers = values.filter(v => v !== sortedCounts[0].val);
                return { name: 'Four of a Kind', score: 8, ranks: [sortedCounts[0].val, sortedCounts[0].val, sortedCounts[0].val, sortedCounts[0].val, ...kickers] };
            }

            if (sortedCounts[0].count === 3 && sortedCounts[1].count === 2) {
                return { name: 'Full House', score: 7, ranks: [sortedCounts[0].val, sortedCounts[0].val, sortedCounts[0].val, sortedCounts[1].val, sortedCounts[1].val] };
            }

            if (isFlush) {
                return { name: 'Flush', score: 6, ranks: values };
            }

            if (isStraight || isAceLowStraight) {
                return { name: 'Straight', score: 5, ranks: isAceLowStraight ? [5, 4, 3, 2, 1] : values };
            }

            if (sortedCounts[0].count === 3) {
                const kickers = values.filter(v => v !== sortedCounts[0].val).sort((a, b) => b - a);
                return { name: 'Three of a Kind', score: 4, ranks: [sortedCounts[0].val, sortedCounts[0].val, sortedCounts[0].val, ...kickers] };
            }

            if (sortedCounts[0].count === 2 && sortedCounts[1].count === 2) {
                const pairs = [sortedCounts[0].val, sortedCounts[1].val].sort((a, b) => b - a);
                const kicker = values.filter(v => v !== pairs[0] && v !== pairs[1])[0];
                return { name: 'Two Pair', score: 3, ranks: [pairs[0], pairs[0], pairs[1], pairs[1], kicker] };
            }

            if (sortedCounts[0].count === 2) {
                const kickers = values.filter(v => v !== sortedCounts[0].val).sort((a, b) => b - a);
                return { name: 'Pair', score: 2, ranks: [sortedCounts[0].val, sortedCounts[0].val, ...kickers] };
            }

            return { name: 'High Card', score: 1, ranks: values };
        }

        function compareHands(hand1, hand2) {
            if (hand1.score !== hand2.score) {
                return hand1.score - hand2.score;
            }
            return compareRanks(hand1.ranks, hand2.ranks);
        }

        function compareRanks(ranks1, ranks2) {
            for (let i = 0; i < Math.min(ranks1.length, ranks2.length); i++) {
                if (ranks1[i] !== ranks2[i]) {
                    return ranks1[i] - ranks2[i];
                }
            }
            return 0;
        }

        function updatePlayerDisplay(index) {
            updateDisplay();
        }

        function showMessage(text, duration = 2000) {
            const msg = document.getElementById('message');
            msg.textContent = text;
            msg.classList.add('show');
            setTimeout(() => {
                msg.classList.remove('show');
            }, duration);
        }
    </script>
</body>
</html>
